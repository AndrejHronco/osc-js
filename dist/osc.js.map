{"version":3,"file":null,"sources":["../src/common/utils.js","../src/common/helpers.js","../src/atomic.js","../src/atomic/timetag.js","../src/events.js","../src/atomic/int32.js","../src/atomic/float32.js","../src/atomic/float64.js","../src/atomic/string.js","../src/atomic/blob.js","../src/message.js","../src/bundle.js","../src/packet.js","../src/osc.js"],"sourcesContent":["/**\n * Check if given object is an integer number\n * @param {*} n\n * @return {boolean}\n */\nexport function isInt(n) {\n  return Number(n) === n && n % 1 === 0\n}\n\n/**\n * Check if given object is a float number\n * @param {*} n\n * @return {boolean}\n */\nexport function isFloat(n) {\n  return Number(n) === n && n % 1 !== 0\n}\n\n/**\n * Check if given object is a string\n * @param {*} n\n * @return {boolean}\n */\nexport function isString(n) {\n  return typeof n === 'string'\n}\n\n/**\n * Check if given object is an array\n * @param {*} n\n * @return {boolean}\n */\nexport function isArray(n) {\n  return Object.prototype.toString.call(n) === '[object Array]'\n}\n\n/**\n * Check if given object is an object\n * @param {*} n\n * @return {boolean}\n */\nexport function isObject(n) {\n  return Object.prototype.toString.call(n) === '[object Object]'\n}\n\n/**\n * Check if given object is a function\n * @param {*} n\n * @return {boolean}\n */\nexport function isFunction(n) {\n  return typeof n === 'function'\n}\n\n/**\n * Check if given object is a Uint8Array\n * @param {*} n\n * @return {boolean}\n */\nexport function isBlob(n) {\n  return n instanceof Uint8Array\n}\n\n/**\n * Check if given object is a Date\n * @param {*} n\n * @return {boolean}\n */\nexport function isDate(n) {\n  return n instanceof Date\n}\n\n/**\n * Return the next multiple of four\n * @param {number} n\n */\nexport function pad(n) {\n  return (n + 3) & ~0x03\n}\n","import { isArray, isInt, isFloat, isString, isBlob } from './utils'\n\n/**\n * Checks type of given item and returns its OSC Type tag\n * @param {*} item Any object\n * @return {string} OSC Type tag of given object as string\n */\nexport function typeTag(item) {\n  if (isInt(item)) {\n    return 'i'\n  } else if (isFloat(item)) {\n    return 'f'\n  } else if (isString(item)) {\n    return 's'\n  } else if (isBlob(item)) {\n    return 'b'\n  }\n\n  throw new Error('OSC Message found unknown value type.')\n}\n\n/**\n * Sanitizes an OSC ready OSC Address Pattern\n * @param {array|string} obj Address as string or array of strings\n * @return {string} Correct address string\n *\n * @example\n * // returns '/test/path' string:\n * prepareAddress('test/path')\n * prepareAddress('/test/path/')\n * prepareAddress([test, path])\n */\nexport function prepareAddress(obj) {\n  let address = ''\n\n  if (isArray(obj)) {\n    return `/${obj.join('/')}`\n  } else if (isString(obj)) {\n    address = obj\n\n    // remove slash at ending of address\n    if (address.length > 1 && address[address.length - 1] === '/') {\n      address = address.slice(0, address.length - 1)\n    }\n\n    // add slash at beginning of address\n    if (address.length > 1 && address[0] !== '/') {\n      address = `/${address}`\n    }\n\n    return address\n  }\n\n  throw new Error('OSC Helpers can only prepare addresses which are of type array or string.')\n}\n\n/**\n * Make an OSC address pattern javascript-regex-ready\n * @param {string} str OSC address pattern\n * @return {string} Javascript RegEx string\n */\nexport function prepareRegExPattern(str) {\n  let pattern\n\n  if (!(isString(str))) {\n    throw new Error('OSC Helper prepareRegExPattern only accepts strings.')\n  }\n\n  pattern = str.replace(/\\./g, '\\\\.')\n  pattern = pattern.replace(/\\(/g, '\\\\(')\n  pattern = pattern.replace(/\\)/g, '\\\\)')\n\n  pattern = pattern.replace(/\\{/g, '(')\n  pattern = pattern.replace(/\\}/g, ')')\n  pattern = pattern.replace(/,/g, '|')\n\n  pattern = pattern.replace(/\\[!/g, '[^')\n\n  pattern = pattern.replace(/\\?/g, '.')\n  pattern = pattern.replace(/\\*/g, '.*')\n\n  return pattern\n}\n\n/**\n * Holds a list of items and helps to merge them\n * into a single array of packed binary data.\n */\nexport default class EncodeHelper {\n  /**\n   * Create a new EncodeHelper instance\n   */\n  constructor() {\n    /** @type {array} data */\n    this.data = []\n    /** @type {number} byteLength */\n    this.byteLength = 0\n  }\n\n  /**\n   * Packs an item and adds it to the list\n   * @param {*} item Any object\n   * @return {EncodeHelper}\n   */\n  add(item) {\n    const buffer = item.pack()\n    this.byteLength += buffer.byteLength\n    this.data.push(buffer)\n\n    return this\n  }\n\n  /**\n   * Merge all added items into one Uint8Array\n   * @return {Uint8Array} Merged binary data array of all items\n   */\n  merge() {\n    const result = new Uint8Array(this.byteLength)\n    let offset = 0\n\n    this.data.forEach((data) => {\n      result.set(data, offset)\n      offset += data.byteLength\n    })\n\n    return result\n  }\n}\n","/**\n * Base class for OSC Atomic Data Types.\n */\nexport default class Atomic {\n  /**\n   * Create an Atomic instance\n   * @param {*} value Initial value of any type\n   */\n  constructor(value) {\n    /** @type {*} value */\n    this.value = value\n    /** @type {number} offset */\n    this.offset = 0\n  }\n\n  /**\n   * Interpret the given value of this entity as packed binary data\n   * @param {string} method The DataView method to write to the ArrayBuffer\n   * @param {number} byteLength Size of array in bytes\n   * @return {Uint8Array} Packed binary data\n   */\n  pack(method, byteLength) {\n    if (!(method && byteLength)) {\n      throw new Error('OSC Atomic cant\\'t be packed without given method or byteLength.')\n    }\n\n    const data = new Uint8Array(byteLength)\n    const dataView = new DataView(data.buffer)\n\n    if (!this.value) {\n      throw new Error('OSC Atomic cant\\'t be encoded with empty value.')\n    }\n\n    // use DataView to write to ArrayBuffer\n    dataView[method](this.offset, this.value, false)\n\n    // always return binary Uint8Array after packing\n    return data\n  }\n\n /**\n   * Unpack binary data from DataView according to the given format\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {string} method The DataView method to read the format from the ArrayBuffer\n   * @param {number} byteLength Size of array in bytes\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, method, byteLength, initialOffset = 0) {\n    if (!(dataView && method && byteLength)) {\n      throw new Error('OSC Atomic cant\\'t be unpacked without given dataView, method or byteLength.')\n    }\n\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Atomic expects an instance of type DataView.')\n    }\n\n    // use DataView to read from ArrayBuffer and add offset\n    this.value = dataView[method](initialOffset, false)\n    this.offset = initialOffset + byteLength\n\n    // always return offset number after unpacking\n    return this.offset\n  }\n}\n","import { isInt, isDate } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/** 70 years in seconds */\nexport const SECONDS_70_YEARS = 2208988800\n/** 2^32 */\nexport const TWO_POWER_32 = 4294967296\n\n/**\n * Timetag helper class for representing NTP timestamps and conversion between\n * them and javascript representation.\n */\nexport class Timetag {\n  /**\n   * Create a Timetag instance.\n   * @param {number} seconds Initial NTP seconds value\n   * @param {number} fractions Initial NTP fractions value\n   */\n  constructor(seconds = 0, fractions = 0) {\n    if (!(isInt(seconds) && isInt(fractions))) {\n      throw new Error('OSC Timetag constructor expects values of type integer number.')\n    }\n\n    /** @type {number} seconds */\n    this.seconds = seconds\n    /** @type {number} fractions */\n    this.fractions = fractions\n  }\n\n  /**\n   * Converts from NTP to JS representation and back\n   * @param {number} milliseconds Converts from JS milliseconds to NTP and write seconds\n   * and fractions. Leave empty for returning the converted javascript timestamp from the\n   * NTP representation\n   * @return {number} Javascript timestamp\n   */\n  timestamp(milliseconds) {\n    let seconds\n\n    if (typeof milliseconds === 'number') {\n      seconds = milliseconds / 1000\n      const rounded = Math.floor(seconds)\n\n      this.seconds = rounded + SECONDS_70_YEARS\n      this.fractions = Math.round(TWO_POWER_32 * (seconds - rounded))\n\n      return milliseconds\n    }\n\n    seconds = this.seconds - SECONDS_70_YEARS\n    return (seconds + (this.fractions / TWO_POWER_32)) * 1000\n  }\n}\n\n/**\n * 64-bit big-endian fixed-point time tag, semantics defined below OSC Atomic Data Type.\n */\nexport default class AtomicTimetag extends Atomic {\n  /**\n   * Create a AtomicTimetag instance\n   * @param {number|Timetag|Date} value Initial date, leave empty if\n   * you want it to be the current date\n   */\n  constructor(value) {\n    let timetag = new Timetag()\n\n    if (value instanceof Timetag) {\n      timetag = value\n    } else if (isInt(value)) {\n      timetag.timestamp(value)\n    } else if (isDate(value)) {\n      timetag.timestamp(value.getTime())\n    } else {\n      // set to current date when nothing was given\n      timetag.timestamp(Date.now())\n    }\n\n    super(timetag)\n  }\n\n  /**\n   * Interpret the given timetag as packed binary data.\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC AtomicTimetag can not be encoded with empty value.')\n    }\n\n    const { seconds, fractions } = this.value\n    const data = new Uint8Array(8)\n    const dataView = new DataView(data.buffer)\n\n    dataView.setInt32(0, seconds, false)\n    dataView.setInt32(4, fractions, false)\n\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView and read a timetag.\n   * @param {DataView} dataView The DataView holding the binary representation of the timetag\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicTimetag expects an instance of type DataView.')\n    }\n\n    const seconds = dataView.getUint32(initialOffset, false)\n    const fractions = dataView.getUint32(initialOffset + 4, false)\n\n    /** @type {Timetag} value */\n    this.value = new Timetag(seconds, fractions)\n    /** @type {number} offset */\n    this.offset = initialOffset + 8\n\n    return this.offset\n  }\n}\n","import { isArray, isString, isInt, isFunction } from './common/utils'\nimport { prepareAddress, prepareRegExPattern } from './common/helpers'\n\nimport { option } from './osc'\n\nimport { Timetag } from './atomic/timetag'\n\n/**\n * EventHandler to notify listener on address pattern match of incoming\n * Message while caring about timetags (later notification). The EventHandler\n * is also handling status changes of connection plugins.\n */\nexport default class EventHandler {\n  /**\n   * Create an EventHandler instance\n   * @param {object} options OSC instance options\n   */\n  constructor() {\n    /** @type {array} addressHandlers */\n    this.addressHandlers = []\n    /** @type {object} eventHandlers */\n    this.eventHandlers = {\n      open: [],\n      error: [],\n      close: [],\n    }\n    /** @type {number} uuid */\n    this.uuid = 0\n  }\n\n  /**\n   * Find a matching event handler and notify the listeners when given\n   * @param {string} eventName The OSC address pattern or event name\n   * @param {*} data Data which will be passed onto the listeners\n   * @param {Timetag} timetag Execute this notification with a timetag\n   */\n  notify(eventName, data, timetag) {\n    if (!(isString(eventName))) {\n      throw new Error('OSC EventHandler notify method accepts only strings.')\n    }\n\n    if (timetag && !(timetag instanceof Timetag)) {\n      throw new Error('OSC EventHandler accepts only timetags of type Timetag.')\n    }\n\n    if (timetag) {\n      const now = Date.now()\n\n      if (now > timetag.timestamp()) {\n        if (!option('discardLateMessages')) {\n          this.notify(eventName, data)\n        }\n      } else {\n        const that = this\n\n        // notify later\n        setTimeout(() => {\n          that.notify(eventName, data)\n        }, timetag.timestamp() - now)\n      }\n\n      return true\n    }\n\n    // call event handlers\n    if (isString(eventName) && eventName in this.eventHandlers) {\n      this.eventHandlers[eventName].forEach((handler) => {\n        handler.callback(data)\n      })\n\n      return true\n    }\n\n    // call address handlers\n    const handlerKeys = Object.keys(this.addressHandlers)\n    const handlers = this.addressHandlers\n\n    handlerKeys.forEach((key) => {\n      const regex = new RegExp(prepareRegExPattern(prepareAddress(eventName)), 'g')\n      const test = regex.test(key)\n\n      // found a matching address in our callback handlers\n      if (test && key.length === regex.lastIndex) {\n        handlers[key].forEach((handler) => {\n          handler.callback(data)\n        })\n      }\n    })\n\n    return true\n  }\n\n  /**\n   * Subscribe to a new address or event you want to listen to\n   * @param {string} eventName The OSC address or event name\n   * @param {function} callback Callback function on notification\n   * @return {number} Subscription Id (needed to unsubscribe)\n   */\n  on(eventName, callback) {\n    if (!(isString(eventName) || isArray(eventName))) {\n      throw new Error('OSC EventHandler accepts only strings or arrays for address patterns.')\n    }\n\n    if (!isFunction(callback)) {\n      throw new Error('OSC EventHandler callback has to be a function.')\n    }\n\n    // get next id\n    this.uuid += 1\n\n    // prepare handler\n    const handler = {\n      id: this.uuid,\n      callback,\n    }\n\n    // register event listener\n    if (isString(eventName) && eventName in this.eventHandlers) {\n      this.eventHandlers[eventName].push(handler)\n      return this.uuid\n    }\n\n    // register address listener\n    const address = prepareAddress(eventName)\n    const regex = new RegExp(/[#*\\s[\\],/{}|?]/g)\n\n    if (regex.test(address.split('/').join(''))) {\n      throw new Error('OSC EventHandler address string contains invalid characters.')\n    }\n\n    if (!(address in this.addressHandlers)) {\n      this.addressHandlers[address] = []\n    }\n\n    this.addressHandlers[address].push(handler)\n\n    return this.uuid\n  }\n\n  /**\n   * Unsubscribe listener from event notification or address handler\n   * @param {string} eventName The OSC address or event name\n   * @param {number} subscriptionId Subscription id to identify the handler\n   * @return {boolean} Success state\n   */\n  off(eventName, subscriptionId) {\n    if (!(isString(eventName) || isArray(eventName))) {\n      throw new Error('OSC EventHandler accepts only strings or arrays for address patterns.')\n    }\n\n    if (!isInt(subscriptionId)) {\n      throw new Error('OSC EventHandler subscription id has to be a number.')\n    }\n\n    let key\n    let haystack\n\n    // event or address listener\n    if (isString(eventName) && eventName in this.eventHandlers) {\n      key = eventName\n      haystack = this.eventHandlers\n    } else {\n      key = prepareAddress(eventName)\n      haystack = this.addressHandlers\n    }\n\n    // remove the entry\n    if (key in haystack) {\n      return haystack[key].some((item, index) => {\n        if (item.id === subscriptionId) {\n          haystack[key].splice(index, 1)\n          return true\n        }\n\n        return false\n      })\n    }\n\n    return false\n  }\n}\n","import { isInt } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 32-bit big-endian two's complement integer OSC Atomic Data Type.\n */\nexport default class AtomicInt32 extends Atomic {\n  /**\n   * Create an AtomicInt32 instance\n   * @param {number} value Initial integer value\n   */\n  constructor(value) {\n    if (value && !isInt(value)) {\n      throw new Error('OSC AtomicInt32 constructor expects value of type number.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setInt32', 4)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Int32 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpack(dataView, 'getInt32', 4, initialOffset)\n  }\n}\n","import { isFloat } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 32-bit big-endian IEEE 754 floating point number OSC Atomic Data Type.\n */\nexport default class AtomicFloat32 extends Atomic {\n  /**\n   * Create an AtomicFloat32 instance\n   * @param {number} value Float number\n   */\n  constructor(value) {\n    if (value && !isFloat(value)) {\n      throw new Error('OSC AtomicFloat32 constructor expects value of type float.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setFloat32', 4)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Float32 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpack(dataView, 'getFloat32', 4, initialOffset)\n  }\n}\n","import { isFloat } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 64-bit big-endian floating point number (double precision) OSC Atomic Data Type.\n * This is a non-standard OSC Data Type but enables us to have more reliable float numbers when\n * precision is crucial. Enable the 64-bit float setting in the options to make use of them.\n */\nexport default class AtomicFloat64 extends Atomic {\n  /**\n   * Create an AtomicFloat64 instance\n   * @param {number} value Float number\n   */\n  constructor(value) {\n    if (value && !isFloat(value)) {\n      throw new Error('OSC AtomicFloat64 constructor expects value of type float number.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setFloat64', 8)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Float64 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpack(dataView, 'getFloat64', 8, initialOffset)\n  }\n}\n","import { pad, isString } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * A sequence of non-null ASCII characters OSC Atomic Data Type.\n */\nexport default class AtomicString extends Atomic {\n  /**\n   * Create an AtomicString instance\n   * @param {string} value Initial string value\n   */\n  constructor(value) {\n    if (value && !isString(value)) {\n      throw new Error('OSC AtomicString constructor expects value of type string.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given string as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC AtomicString can not be encoded with empty value.')\n    }\n\n    // add 0-3 null characters for total number of bits a multiple of 32\n    const terminated = `${this.value}\\u0000`\n    const byteLength = pad(terminated.length)\n\n    const buffer = new Uint8Array(byteLength)\n\n    for (let i = 0; i < terminated.length; i += 1) {\n      buffer[i] = terminated.charCodeAt(i)\n    }\n\n    return buffer\n  }\n\n  /**\n   * Unpack binary data from DataView and read a string\n   * @param {DataView} dataView The DataView holding the binary representation of the string\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicString expects an instance of type DataView.')\n    }\n\n    let offset = initialOffset\n    let charcode\n    const data = []\n\n    for (; offset < dataView.byteLength; offset += 1) {\n      charcode = dataView.getUint8(offset)\n\n      // check for terminating null character\n      if (charcode !== 0) {\n        data.push(charcode)\n      } else {\n        offset += 1\n        break\n      }\n    }\n\n    if (offset === dataView.length) {\n      throw new Error('OSC AtomicString found a malformed OSC string.')\n    }\n\n    /** @type {number} offset */\n    this.offset = pad(offset)\n    /** @type {string} value */\n    this.value = String.fromCharCode.apply(null, data)\n\n    return this.offset\n  }\n}\n","import { pad, isBlob } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 8-bit bytes of arbitrary binary data OSC Atomic Data Type.\n */\nexport default class AtomicBlob extends Atomic {\n  /**\n   * Create an AtomicBlob instance\n   * @param {Uint8Array} value Binary data\n   */\n  constructor(value) {\n    if (value && !isBlob(value)) {\n      throw new Error('OSC AtomicBlob constructor expects value of type Uint8Array.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given blob as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC AtomicBlob can not be encoded with empty value.')\n    }\n\n    const byteLength = pad(this.value.byteLength)\n    const data = new Uint8Array(byteLength + 4)\n    const dataView = new DataView(data.buffer)\n\n    // an int32 size count\n    dataView.setInt32(0, this.value.byteLength, false)\n    // followed by 8-bit bytes of arbitrary binary data\n    data.set(this.value, 4)\n\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView and read a blob\n   * @param {DataView} dataView The DataView holding the binary representation of the blob\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicBlob expects an instance of type DataView.')\n    }\n\n    const byteLength = dataView.getInt32(initialOffset, false)\n\n    /** @type {Uint8Array} value */\n    this.value = new Uint8Array(dataView.buffer, initialOffset + 4, byteLength)\n    /** @type {number} offset */\n    this.offset = pad(initialOffset + 4 + byteLength)\n\n    return this.offset\n  }\n}\n","import { isString, isArray, isInt, isFloat, isBlob } from './common/utils'\nimport Helper, { typeTag, prepareAddress } from './common/helpers'\n\nimport { option } from './osc'\n\nimport AtomicInt32 from './atomic/int32'\nimport AtomicFloat32 from './atomic/float32'\nimport AtomicFloat64 from './atomic/float64'\nimport AtomicString from './atomic/string'\nimport AtomicBlob from './atomic/blob'\n\n/**\n * An OSC message consists of an OSC Address Pattern followed\n * by an OSC Type Tag String followed by zero or more OSC Arguments.\n */\nexport default class Message {\n  /**\n   * Create a Message instance\n   * @param {array|string} args Address\n   * @param {...*} args OSC Atomic Data Types\n   *\n   * @example\n   * const message = new Message(['test', 'path'], 50, 100.52, 'test')\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   */\n  constructor(...args) {\n    /** @type {number} offset */\n    this.offset = 0\n    /** @type {string} address */\n    this.address = ''\n    /** @type {string} types */\n    this.types = ''\n    /** @type {array} args */\n    this.args = []\n    /** @type {AtomicTimetag} timetag */\n    this.timetag = null // non OSC standard\n\n    if (args.length > 0) {\n      if (!(isString(args[0]) || isArray(args[0]))) {\n        throw new Error('OSC Message constructor first argument (address) must be a string or array.')\n      }\n\n      this.address = prepareAddress(args.shift())\n      this.types = args.map(item => typeTag(item)).join('')\n      this.args = args\n    }\n  }\n\n  /**\n   * Add a OSC Atomic Data Type to the list of elements\n   * @param {*} item\n   */\n  add(item) {\n    if (!item) {\n      throw new Error('OSC Message expects a valid item for adding.')\n    }\n\n    this.args.push(item)\n    this.types += typeTag(item)\n  }\n\n  /**\n   * Interpret the Message as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (this.address.length === 0 || this.address[0] !== '/') {\n      throw new Error('OSC Message does not have a proper address.')\n    }\n\n    const encoder = new Helper()\n\n    // OSC Address Pattern and Type string\n    encoder.add(new AtomicString(this.address))\n    encoder.add(new AtomicString(`,${this.types}`))\n\n    // followed by zero or more OSC Arguments\n    if (this.args.length > 0) {\n      let argument\n\n      this.args.forEach((value) => {\n        if (isInt(value)) {\n          argument = new AtomicInt32(value)\n        } else if (isFloat(value)) {\n          if (option('doublePrecisionFloats')) {\n            argument = new AtomicFloat64(value)\n          } else {\n            argument = new AtomicFloat32(value)\n          }\n        } else if (isString(value)) {\n          argument = new AtomicString(value)\n        } else if (isBlob(value)) {\n          argument = new AtomicBlob(value)\n        } else {\n          throw new Error('OSC Message found unknown argument type.')\n        }\n\n        encoder.add(argument)\n      })\n    }\n\n    return encoder.merge()\n  }\n\n  /**\n   * Unpack binary data to read a Message\n   * @param {DataView} dataView The DataView holding the binary representation of a Message\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Message expects an instance of type DataView.')\n    }\n\n    // read address pattern\n    const address = new AtomicString()\n    address.unpack(dataView, initialOffset)\n\n    // read type string\n    const types = new AtomicString()\n    types.unpack(dataView, address.offset)\n\n    if (address.value.length === 0 || address.value[0] !== '/') {\n      throw new Error('OSC Message found malformed or missing address string.')\n    }\n\n    if (types.value.length === 0 && types.value[0] !== ',') {\n      throw new Error('OSC Message found malformed or missing type string.')\n    }\n\n    let offset = types.offset\n    let next\n    let type\n\n    const args = []\n\n    // read message arguments (OSC Atomic Data Types)\n    for (let i = 1; i < types.value.length; i += 1) {\n      type = types.value[i]\n\n      if (type === 'i') {\n        next = new AtomicInt32()\n      } else if (type === 'f') {\n        if (option('doublePrecisionFloats')) {\n          next = new AtomicFloat64()\n        } else {\n          next = new AtomicFloat32()\n        }\n      } else if (type === 's') {\n        next = new AtomicString()\n      } else if (type === 'b') {\n        next = new AtomicBlob()\n      } else {\n        throw new Error('OSC Message found non-standard argument type.')\n      }\n\n      offset = next.unpack(dataView, offset)\n      args.push(next.value)\n    }\n\n    this.offset = offset\n    this.address = address.value\n    this.types = types.value\n    this.args = args\n\n    return this.offset\n  }\n}\n","import { isArray, isInt } from './common/utils'\nimport EncodeHelper from './common/helpers'\n\nimport Packet from './packet'\nimport Message from './message'\nimport AtomicString from './atomic/string'\nimport AtomicInt32 from './atomic/int32'\nimport AtomicTimetag from './atomic/timetag'\n\n/** OSC Bundle string */\nexport const BUNDLE_TAG = '#bundle'\n\n/**\n * An OSC Bundle consist of an Timetag and Bundle Elements.\n * The contents are either OSC Messages or more OSC Bundles.\n */\nexport default class Bundle {\n  /**\n   * Create a Bundle instance\n   * @param {...*} args Timetag and elements\n   *\n   * @example\n   * const bundle = new Bundle(new Date() + 500)\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   * const anotherBundle = new Bundle([message], Date.now() + 1500)\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   * const anotherMessage = new Message('/test/message', 'test', 12)\n   * const anotherBundle = new Bundle(message, anotherMessage)\n   */\n  constructor(...args) {\n    /** @type {number} offset */\n    this.offset = 0\n    /** @type {AtomicTimetag} timetag */\n    this.timetag = new AtomicTimetag()\n    /** @type {array} bundleElements */\n    this.bundleElements = []\n\n    if (args.length > 0) {\n      // first argument is an Date or js timestamp (number)\n      if (args[0] instanceof Date || isInt(args[0])) {\n        this.timetag = new AtomicTimetag(args[0])\n      } else if (isArray(args[0])) {\n        // first argument is an Array of Bundle elements\n        args[0].forEach((item) => {\n          this.add(item)\n        })\n\n        // second argument is an Date or js timestamp (number)\n        if (args.length > 1 && (args[1] instanceof Date || isInt(args[0]))) {\n          this.timetag = new AtomicTimetag(args[1])\n        }\n      } else {\n        // take all arguments as Bundle elements\n        args.forEach((item) => {\n          this.add(item)\n        })\n      }\n    }\n  }\n\n  /**\n   * Take a JavaScript timestamp to set the Bundle's timetag\n   * @param {number} ms JS timestamp in milliseconds\n   *\n   * @example\n   * const bundle = new Bundle()\n   * bundle.timestamp(Date.now() + 5000) // in 5 seconds\n   */\n  timestamp(ms) {\n    if (!isInt(ms)) {\n      throw new Error('OSC Bundle needs an Integer for setting its timestamp.')\n    }\n\n    this.timetag = new AtomicTimetag(ms)\n  }\n\n  /**\n   * Add a Message or Bundle to the list of elements\n   * @param {Bundle|Message} item\n   */\n  add(item) {\n    if (!(item instanceof Message || item instanceof Bundle)) {\n      throw new Error('OSC Bundle contains only Messages and Bundles.')\n    }\n\n    this.bundleElements.push(item)\n  }\n\n  /**\n   * Interpret the Bundle as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    const encoder = new EncodeHelper()\n\n    // an OSC Bundle consists of the OSC-string \"#bundle\"\n    encoder.add(new AtomicString(BUNDLE_TAG))\n\n    // followed by an OSC Time Tag\n    if (!this.timetag) {\n      this.timetag = new AtomicTimetag()\n    }\n\n    encoder.add(this.timetag)\n\n    // followed by zero or more OSC Bundle Elements\n    this.bundleElements.forEach((item) => {\n      encoder.add(new AtomicInt32(item.pack().byteLength))\n      encoder.add(item)\n    })\n\n    return encoder.merge()\n  }\n\n  /**\n   * Unpack binary data to read a Bundle\n   * @param {DataView} dataView The DataView holding the binary representation of a Bundle\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Bundle expects an instance of type DataView.')\n    }\n\n    // read the beginning bundle string\n    const head = new AtomicString()\n    head.unpack(dataView, initialOffset)\n\n    if (head.value !== BUNDLE_TAG) {\n      throw new Error('OSC Bundle does not contain a valid #bundle head.')\n    }\n\n    // read the timetag\n    const timetag = new AtomicTimetag()\n    let offset = timetag.unpack(dataView, head.offset)\n\n    // read the bundle elements\n    this.bundleElements = []\n\n    while (offset < dataView.byteLength) {\n      const packet = new Packet()\n      const size = new AtomicInt32()\n\n      offset = size.unpack(dataView, offset)\n      offset = packet.unpack(dataView, offset, this.timetag)\n\n      this.bundleElements.push(packet.value)\n    }\n\n    this.offset = offset\n    this.timetag = timetag\n\n    return this.offset\n  }\n}\n","import EventHandler from './events'\n\nimport Bundle, { BUNDLE_TAG } from './bundle'\nimport Message from './message'\nimport AtomicString from './atomic/string'\n\n/**\n * The unit of transmission of OSC is an OSC Packet. The contents\n * of an OSC packet must be either an OSC Message or an OSC Bundle.\n */\nexport default class Packet {\n  /**\n   * Create a Packet instance holding a Message or Bundle\n   * @param {Message|Bundle} value Initial Packet value\n   */\n  constructor(value) {\n    if (value && !(value instanceof Message || value instanceof Bundle)) {\n      throw new Error('OSC Packet can only consist of Message or Bundle.')\n    }\n\n    /** @type {Message|Bundle} value */\n    this.value = value\n    /** @type {number} offset */\n    this.offset = 0\n  }\n\n  /**\n   * Packs the Packet value, this is more like a wrapper, you could also skip\n   * the Packet and directly pack the Message or Bundle.\n   * @return {Uint8Array} Packed binary data\n   *\n   * @example\n   * const message = new Message('/test/path', 21.5, 'test')\n   * const packet = new Packet(message)\n   * const packetBinary = packet.pack() // then send it via udp etc.\n   *\n   * // or skip the Packet for convenience\n   * const messageBinary = message.pack()\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC Packet can not be encoded with empty body.')\n    }\n\n    return this.value.pack()\n  }\n\n  /**\n   * Unpack binary data from DataView for Messages or Bundles\n   * @param {DataView} dataView The DataView holding the binary representation of a Packet\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @param {AtomicTimetag} timetag Pass over a AtomicTimetag, this is needed to inherit\n   * timetags from parent Bundles\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0, timetag) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Packet expects an instance of type DataView.')\n    }\n\n    if (dataView.byteLength % 4 !== 0) {\n      throw new Error('OSC Packet byteLength has to be a multiple of four.')\n    }\n\n    const head = new AtomicString()\n    head.unpack(dataView, initialOffset)\n\n    let item\n\n    // check if Packet is a Bundle or a Message\n    if (head.value === BUNDLE_TAG) {\n      item = new Bundle()\n      item.unpack(dataView, initialOffset)\n\n      if (timetag && item.timetag.value.timestamp() < timetag.timestamp()) {\n        throw new Error('OSC Packet timetag of enclosing bundle is past timestamp of enclosed ones.')\n      }\n    } else {\n      item = new Message()\n      item.unpack(dataView, initialOffset)\n\n      // get singleton instance\n      const eventHandler = new EventHandler()\n\n      // inherit the AtomicTimetag from the parent bundle when passed over\n      if (timetag) {\n        item.timetag = timetag\n\n        // inform event handler with timed message\n        eventHandler.notify(item.address, item, item.timetag.value)\n      } else {\n        eventHandler.notify(item.address, item)\n      }\n    }\n\n    this.offset = item.offset\n    this.value = item\n\n    return this.offset\n  }\n}\n","import { isObject, isString, isFunction, isInt } from './common/utils'\n\nimport Packet from './packet'\nimport Bundle from './bundle'\nimport Message from './message'\n\nimport EventHandler from './events'\n\n/**\n * Default options.\n * @private\n */\nconst defaultOptions = {\n  connectionPlugin: null,\n  doublePrecisionFloats: false,\n  discardLateMessages: false,\n}\n\n/**\n * Status flags.\n */\nexport const STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Singleton instance.\n * @private\n */\nlet instance = null\n\n/**\n * Helper method to get options of singleton instance. If instance\n * does not exist (low level access) we take the default options.\n * @param {string} key Key of the option\n * @return {*} Value of requested option\n */\nexport function option(key) {\n  const options = instance ? instance.options : defaultOptions\n\n  if (!(key in options) || !isString(key)) {\n    throw new Error('OSC option key does not exist or is not valid.')\n  }\n\n  return options[key]\n}\n\n/**\n * OSC interface to send OSC Packets and listen to status changes and\n * incoming message events. Offers a Plugin API for different network\n * protocols.\n */\nexport default class OSC {\n  /**\n   * Create an OSC instance with given options\n   * @param {object} options Custom options\n   * @param {boolean} [options.doublePrecisionFloats=false] Use double precision floats (64 bit)\n   * for higher float precision. Default setting uses 32bit floats which is the OSC standard\n   * @param {string} options.connectionPlugin Add a connection plugin to this interface (this\n   * is recommended). Pass over the instance here. Check out the README for further informations.\n   *\n   * @example\n   * const osc = new OSC({ doublePrecisionFloats: true })\n   *\n   * @example\n   * const websocketPlugin = new OSCWebsocket()\n   * const osc = new OSC({ connectionPlugin: websocketPlugin })\n   */\n  constructor(options = {}) {\n    // singleton pattern\n    if (!instance) {\n      instance = this\n    }\n\n    if (!isObject(options)) {\n      throw new Error('OSC options argument has to be an object.')\n    }\n\n    /** @type {object} options */\n    this.options = Object.assign({}, defaultOptions, options)\n    /** @type {EventHandler} eventHandler */\n    this.eventHandler = new EventHandler()\n\n    // pass over EventHandler to connectionPlugin\n    if (this.options.connectionPlugin && this.options.connectionPlugin.registerNotify) {\n      this.options.connectionPlugin.registerNotify((...args) =>\n        instance.eventHandler.notify(...args)\n      )\n    }\n\n    return instance\n  }\n\n  /**\n   * Listen to an event or OSC address pattern. The OSC address listener\n   * notification is capable of address pattern matching. Use a connection\n   * plugin or write your own for full functionality of this feature\n   * (see Plugin API for more informations)\n   * @param {string} eventName Event name or OSC address pattern\n   * @param {function} callback Function which is called on notification\n   * @return {number} Subscription id (needed to unsubscribe)\n   *\n   * @example\n   * // will be called when server receives /in!trument/* for example\n   * osc.on('/instrument/1', (message) => {\n   *   console.log(message)\n   * })\n   *\n   * @example\n   * osc.on('error', (message) => {\n   *   console.log(message)\n   * })\n   */\n  on(eventName, callback) {\n    if (!(isString(eventName) && isFunction(callback))) {\n      throw new Error('OSC event listener needs an event or address string and a function as callback.')\n    }\n\n    return this.eventHandler.on(eventName, callback)\n  }\n\n  /**\n   * Unsubscribe event listener\n   * @param {string} eventName Event name or OSC address pattern\n   * @param {number} subscriptionId The subscription id\n   * @return {boolean} Success state\n   *\n   * @example\n   * const listener = osc.on('error', (message) => {\n   *   console.log(message)\n   * })\n   * osc.off('error', listener) // unsubscribe from error event\n   */\n  off(eventName, subscriptionId) {\n    if (!(isString(eventName) && isInt(subscriptionId))) {\n      throw new Error('OSC listener needs a string and a listener id number to unsubscribe from event.')\n    }\n\n    return this.eventHandler.off(eventName, subscriptionId)\n  }\n\n  /**\n   * Open network socket with connection plugin. This method is used by connection plugins\n   * and is not available without (see Plugin API for more informations)\n   * @param {object} options Custom options for plugin instance\n   *\n   * @example\n   * const osc = new OSC({ connectionPlugin: new OSCDatagramW() })\n   * osc.open({ host: '127.0.0.1', port: 8080 })\n   */\n  open(options = {}) {\n    if (!isObject(options)) {\n      throw new Error('OSC connection options argument has to be an object.')\n    }\n\n    if (!(this.options.connectionPlugin && isFunction(this.options.connectionPlugin.open))) {\n      throw new Error('OSC connection#open is not implemented.')\n    }\n\n    return this.options.connectionPlugin.open(options)\n  }\n\n  /**\n   * Returns the current status of the connection. See STATUS for\n   * it's different possible states. This method is used by connection plugins\n   * and is not available without (see Plugin API for more informations)\n   * @return {number} Status ID\n   *\n   * @example\n   * import OSC, { STATUS } from 'osc'\n   * const osc = new OSC()\n   * if (osc.status() === STATUS.IS_CONNECTING) {\n   *   // do something\n   * }\n   */\n  status() {\n    if (!(this.options.connectionPlugin && isFunction(this.options.connectionPlugin.status))) {\n      throw new Error('OSC connection#status is not implemented.')\n    }\n\n    return this.options.connectionPlugin.status()\n  }\n\n  /**\n   * Close network socket of connection plugin. This method is used by connection plugins\n   * and is not available without (see Plugin API for more informations)\n   */\n  close() {\n    if (!(this.options.connectionPlugin && isFunction(this.options.connectionPlugin.close))) {\n      throw new Error('OSC connection#close is not implemented.')\n    }\n\n    return this.options.connectionPlugin.close()\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message. This method is used by connection plugins\n   * and is not available without (see Plugin API for more informations)\n   * @param {Packet|Bundle|Message} packet OSC Packet, Bundle or Message instance\n   * @param {object} options Custom options for transport instance\n   *\n   * @example\n   * const osc = new OSC({ connectionPlugin: new OSCDatagram() })\n   * osc.open({ host: '127.0.0.1', port: 8080 })\n   *\n   * const message = new OSC.Message('/test/path', 55.1, 57)\n   * osc.send(message)\n   *\n   * @example\n   * osc.send(message, { host: '192.168.178.115', port: 9001 })\n   */\n  send(packet, options = {}) {\n    if (!(this.options.connectionPlugin && isFunction(this.options.connectionPlugin.send))) {\n      throw new Error('OSC connection#send is not implemented.')\n    }\n\n    if (!(packet instanceof Message || packet instanceof Bundle || packet instanceof Packet)) {\n      throw new Error('OSC can only send Messages, Bundles or Packets.')\n    }\n\n    if (!isObject(options)) {\n      throw new Error('OSC connection options argument has to be an object.')\n    }\n\n    return this.options.connectionPlugin.send(packet.pack(this.options), options)\n  }\n}\n"],"names":["isInt","n","Number","isFloat","isString","isArray","Object","prototype","toString","call","isObject","isFunction","isBlob","Uint8Array","isDate","Date","pad","typeTag","item","Error","prepareAddress","obj","address","join","length","slice","prepareRegExPattern","str","pattern","replace","EncodeHelper","data","byteLength","buffer","pack","push","result","offset","forEach","set","Atomic","value","method","dataView","DataView","initialOffset","SECONDS_70_YEARS","TWO_POWER_32","Timetag","seconds","fractions","milliseconds","rounded","Math","floor","round","AtomicTimetag","timetag","timestamp","getTime","now","setInt32","getUint32","EventHandler","addressHandlers","eventHandlers","uuid","eventName","option","notify","that","handler","callback","handlerKeys","keys","handlers","key","regex","RegExp","test","lastIndex","split","subscriptionId","haystack","some","index","id","splice","AtomicInt32","AtomicFloat32","AtomicFloat64","AtomicString","terminated","i","charCodeAt","charcode","getUint8","String","fromCharCode","apply","AtomicBlob","getInt32","Message","types","args","shift","map","encoder","Helper","add","argument","merge","unpack","next","type","BUNDLE_TAG","Bundle","bundleElements","ms","head","packet","Packet","size","eventHandler","defaultOptions","instance","options","OSC","assign","connectionPlugin","registerNotify","on","off","open","status","close","send"],"mappings":"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"}