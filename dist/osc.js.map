{"version":3,"file":null,"sources":["../src/common/utils.js","../src/common/helpers.js","../src/atomic.js","../src/atomic/int32.js","../src/atomic/float32.js","../src/atomic/string.js","../src/atomic/blob.js","../src/message.js","../src/atomic/timetag.js","../src/bundle.js","../src/packet.js"],"sourcesContent":["/**\n * Check if given object is an integer number\n * @param {*} n\n * @return {boolean}\n */\nexport function isInt(n) {\n  return Number(n) === n && n % 1 === 0\n}\n\n/**\n * Check if given object is a float number\n * @param {*} n\n * @return {boolean}\n */\nexport function isFloat(n) {\n  return Number(n) === n && n % 1 !== 0\n}\n\n/**\n * Check if given object is a string\n * @param {*} n\n * @return {boolean}\n */\nexport function isString(n) {\n  return typeof n === 'string'\n}\n\n/**\n * Check if given object is an array\n * @param {*} n\n * @return {boolean}\n */\nexport function isArray(n) {\n  return Object.prototype.toString.call(n) === '[object Array]'\n}\n\n/**\n * Check if given object is a Uint8Array\n * @param {*} n\n * @return {boolean}\n */\nexport function isBlob(n) {\n  return n instanceof Uint8Array\n}\n\n/**\n * Check if given object is a Date\n * @param {*} n\n * @return {boolean}\n */\nexport function isDate(n) {\n  return n instanceof Date\n}\n\n/**\n * Return the next multiple of four\n * @param {number} n\n */\nexport function pad(n) {\n  return (n + 3) & ~0x03\n}\n","import { isArray, isInt, isFloat, isString, isBlob } from './utils'\n\n/**\n * Checks type of given item and returns its OSC Type tag\n * @param {*} item Any object\n * @return {string} OSC Type tag of given object as string\n */\nexport function typeTag(item) {\n  if (isInt(item)) {\n    return 'i'\n  } else if (isFloat(item)) {\n    return 'f'\n  } else if (isString(item)) {\n    return 's'\n  } else if (isBlob(item)) {\n    return 'b'\n  }\n\n  throw new Error('OSC Message found unknown value type.')\n}\n\n/**\n * Sanitizes an OSC ready OSC Address Pattern\n * @param {array|string} obj Address as string or array of strings\n * @return {string} Correct address string\n *\n * @example\n * // returns '/test/path' string:\n * prepareAddress('test/path')\n * prepareAddress('/test/path/')\n * prepareAddress([test, path])\n */\nexport function prepareAddress(obj) {\n  let address = ''\n\n  if (isArray(obj)) {\n    return `/${obj.join('/')}`\n  } else if (isString(obj)) {\n    address = obj\n\n    // remove slash at ending of address\n    if (address.length > 1 && address[address.length - 1] === '/') {\n      address = address.slice(0, address.length - 1)\n    }\n\n    // add slash at beginning of address\n    if (address.length > 1 && address[0] !== '/') {\n      address = `/${address}`\n    }\n\n    return address\n  }\n\n  throw new Error('OSC Helpers can only prepare addresses which are of type array or string.')\n}\n\n/**\n * Holds a list of items and helps to merge them\n * into a single array of packed binary data.\n */\nexport default class EncodeHelper {\n  /**\n   * Create a new EncodeHelper instance\n   */\n  constructor() {\n    /** @type {array} data */\n    this.data = []\n    /** @type {number} byteLength */\n    this.byteLength = 0\n  }\n\n  /**\n   * Packs an item and adds it to the list\n   * @param {*} item Any object\n   * @return {EncodeHelper}\n   */\n  add(item) {\n    const buffer = item.pack()\n    this.byteLength += buffer.byteLength\n    this.data.push(buffer)\n\n    return this\n  }\n\n  /**\n   * Merge all added items into one Uint8Array\n   * @return {Uint8Array} Merged binary data array of all items\n   */\n  merge() {\n    const result = new Uint8Array(this.byteLength)\n    let offset = 0\n\n    this.data.forEach((data) => {\n      result.set(data, offset)\n      offset += data.byteLength\n    })\n\n    return result\n  }\n}\n","/**\n * Base class for OSC Atomic Data Types.\n */\nexport default class Atomic {\n  /**\n   * Create an Atomic instance\n   * @param {*} value Initial value of any type\n   */\n  constructor(value) {\n    /** @type {*} value */\n    this.value = value\n    /** @type {number} offset */\n    this.offset = 0\n  }\n\n  /**\n   * Interpret the given value of this entity as packed binary data\n   * @param {string} method The DataView method to write to the ArrayBuffer\n   * @param {number} byteLength Size of array in bytes\n   * @return {Uint8Array} Packed binary data\n   */\n  pack(method, byteLength) {\n    if (!(method && byteLength)) {\n      throw new Error('OSC Atomic cant\\'t be packed without given method or byteLength.')\n    }\n\n    const data = new Uint8Array(byteLength)\n    const dataView = new DataView(data.buffer)\n\n    if (!this.value) {\n      throw new Error('OSC Atomic cant\\'t be encoded with empty value.')\n    }\n\n    // use DataView to write to ArrayBuffer\n    dataView[method](this.offset, this.value, false)\n\n    // always return binary Uint8Array after packing\n    return data\n  }\n\n /**\n   * Unpack binary data from DataView according to the given format\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {string} method The DataView method to read the format from the ArrayBuffer\n   * @param {number} byteLength Size of array in bytes\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, method, byteLength, initialOffset = 0) {\n    if (!(dataView && method && byteLength)) {\n      throw new Error('OSC Atomic cant\\'t be unpacked without given dataView, method or byteLength.')\n    }\n\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Atomic expects an instance of type DataView.')\n    }\n\n    // use DataView to read from ArrayBuffer and add offset\n    this.value = dataView[method](initialOffset, false)\n    this.offset = initialOffset + byteLength\n\n    // always return offset number after unpacking\n    return this.offset\n  }\n}\n","import { isInt } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 32-bit big-endian two's complement integer OSC Atomic Data Type.\n */\nexport default class AtomicInt32 extends Atomic {\n  /**\n   * Create an AtomicInt32 instance\n   * @param {number} value Initial integer value\n   */\n  constructor(value) {\n    if (value && !isInt(value)) {\n      throw new Error('OSC AtomicInt32 constructor expects value of type number.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setInt32', 4)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Int32 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpack(dataView, 'getInt32', 4, initialOffset)\n  }\n}\n","import { isFloat } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 32-bit big-endian IEEE 754 floating point number OSC Atomic Data Type.\n */\nexport default class AtomicFloat32 extends Atomic {\n  /**\n   * Create an AtomicFloat32 instance\n   * @param {number} value Float number\n   */\n  constructor(value) {\n    if (value && !isFloat(value)) {\n      throw new Error('OSC AtomicFloat32 constructor expects value of type float.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setFloat32', 4)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Float32 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpack(dataView, 'getFloat32', 4, initialOffset)\n  }\n}\n","import { pad, isString } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * A sequence of non-null ASCII characters OSC Atomic Data Type.\n */\nexport default class AtomicString extends Atomic {\n  /**\n   * Create an AtomicString instance\n   * @param {string} value Initial string value\n   */\n  constructor(value) {\n    if (value && !isString(value)) {\n      throw new Error('OSC AtomicString constructor expects value of type string.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given string as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC AtomicString can not be encoded with empty value.')\n    }\n\n    // add 0-3 null characters for total number of bits a multiple of 32\n    const terminated = `${this.value}\\u0000`\n    const byteLength = pad(terminated.length)\n\n    const buffer = new Uint8Array(byteLength)\n\n    for (let i = 0; i < terminated.length; i += 1) {\n      buffer[i] = terminated.charCodeAt(i)\n    }\n\n    return buffer\n  }\n\n  /**\n   * Unpack binary data from DataView and read a string\n   * @param {DataView} dataView The DataView holding the binary representation of the string\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicString expects an instance of type DataView.')\n    }\n\n    let offset = initialOffset\n    let charcode\n    const data = []\n\n    for (; offset < dataView.byteLength; offset += 1) {\n      charcode = dataView.getUint8(offset)\n\n      // check for terminating null character\n      if (charcode !== 0) {\n        data.push(charcode)\n      } else {\n        offset += 1\n        break\n      }\n    }\n\n    if (offset === dataView.length) {\n      throw new Error('OSC AtomicString found a malformed OSC string.')\n    }\n\n    /** @type {number} offset */\n    this.offset = pad(offset)\n    /** @type {string} value */\n    this.value = String.fromCharCode.apply(null, data)\n\n    return this.offset\n  }\n}\n","import { pad, isBlob } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 8-bit bytes of arbitrary binary data OSC Atomic Data Type.\n */\nexport default class AtomicBlob extends Atomic {\n  /**\n   * Create an AtomicBlob instance\n   * @param {Uint8Array} value Binary data\n   */\n  constructor(value) {\n    if (value && !isBlob(value)) {\n      throw new Error('OSC AtomicBlob constructor expects value of type Uint8Array.')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given blob as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC AtomicBlob can not be encoded with empty value.')\n    }\n\n    const byteLength = pad(this.value.byteLength)\n    const data = new Uint8Array(byteLength + 4)\n    const dataView = new DataView(data.buffer)\n\n    // an int32 size count\n    dataView.setInt32(0, this.value.byteLength, false)\n    // followed by 8-bit bytes of arbitrary binary data\n    data.set(this.value, 4)\n\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView and read a blob\n   * @param {DataView} dataView The DataView holding the binary representation of the blob\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicBlob expects an instance of type DataView.')\n    }\n\n    const byteLength = dataView.getInt32(initialOffset, false)\n\n    /** @type {Uint8Array} value */\n    this.value = new Uint8Array(dataView.buffer, initialOffset + 4, byteLength)\n    /** @type {number} offset */\n    this.offset = pad(initialOffset + 4 + byteLength)\n\n    return this.offset\n  }\n}\n","import { isString, isArray, isInt, isFloat, isBlob } from './common/utils'\nimport Helper, { typeTag, prepareAddress } from './common/helpers'\n\nimport AtomicInt32 from './atomic/int32'\nimport AtomicFloat32 from './atomic/float32'\nimport AtomicString from './atomic/string'\nimport AtomicBlob from './atomic/blob'\n\n/**\n * An OSC message consists of an OSC Address Pattern followed\n * by an OSC Type Tag String followed by zero or more OSC Arguments.\n */\nexport default class Message {\n  /**\n   * Create a Message instance\n   * @param {array|string} args Address\n   * @param {...*} args OSC Atomic Data Types\n   *\n   * @example\n   * const message = new Message(['test', 'path'], 50, 100.52, 'test')\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   */\n  constructor(...args) {\n    /** @type {number} offset */\n    this.offset = 0\n    /** @type {string} address */\n    this.address = ''\n    /** @type {string} types */\n    this.types = ''\n    /** @type {array} args */\n    this.args = []\n    /** @type {AtomicTimetag} timetag */\n    this.timetag = null // non OSC standard\n\n    if (args.length > 0) {\n      if (!(isString(args[0]) || isArray(args[0]))) {\n        throw new Error('OSC Message constructor first argument (address) must be a string or array.')\n      }\n\n      this.address = prepareAddress(args.shift())\n      this.types = args.map(item => typeTag(item)).join('')\n      this.args = args\n    }\n  }\n\n  /**\n   * Add a OSC Atomic Data Type to the list of elements\n   * @param {*} item\n   */\n  add(item) {\n    if (!item) {\n      throw new Error('OSC Message expects a valid item for adding.')\n    }\n\n    this.args.push(item)\n    this.types += typeTag(item)\n  }\n\n  /**\n   * Interpret the Message as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (this.address.length === 0 || this.address[0] !== '/') {\n      throw new Error('OSC Message does not have a proper address.')\n    }\n\n    const encoder = new Helper()\n\n    // OSC Address Pattern and Type string\n    encoder.add(new AtomicString(this.address))\n    encoder.add(new AtomicString(`,${this.types}`))\n\n    // followed by zero or more OSC Arguments\n    if (this.args.length > 0) {\n      let argument\n\n      this.args.forEach((value) => {\n        if (isInt(value)) {\n          argument = new AtomicInt32(value)\n        } else if (isFloat(value)) {\n          argument = new AtomicFloat32(value)\n        } else if (isString(value)) {\n          argument = new AtomicString(value)\n        } else if (isBlob(value)) {\n          argument = new AtomicBlob(value)\n        } else {\n          throw new Error('OSC Message found unknown argument type.')\n        }\n\n        encoder.add(argument)\n      })\n    }\n\n    return encoder.merge()\n  }\n\n  /**\n   * Unpack binary data to read a Message\n   * @param {DataView} dataView The DataView holding the binary representation of a Message\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Message expects an instance of type DataView.')\n    }\n\n    // read address pattern\n    const address = new AtomicString()\n    address.unpack(dataView, initialOffset)\n\n    // read type string\n    const types = new AtomicString()\n    types.unpack(dataView, address.offset)\n\n    if (address.value.length === 0 || address.value[0] !== '/') {\n      throw new Error('OSC Message found malformed or missing address string.')\n    }\n\n    if (types.value.length === 0 && types.value[0] !== ',') {\n      throw new Error('OSC Message found malformed or missing type string.')\n    }\n\n    let offset = types.offset\n    let next\n    let type\n\n    const args = []\n\n    // read message arguments (OSC Atomic Data Types)\n    for (let i = 1; i < types.value.length; i += 1) {\n      type = types.value[i]\n\n      if (type === 'i') {\n        next = new AtomicInt32()\n      } else if (type === 'f') {\n        next = new AtomicFloat32()\n      } else if (type === 's') {\n        next = new AtomicString()\n      } else if (type === 'b') {\n        next = new AtomicBlob()\n      } else {\n        throw new Error('OSC Message found non-standard argument type.')\n      }\n\n      offset = next.unpack(dataView, offset)\n      args.push(next.value)\n    }\n\n    this.offset = offset\n    this.address = address.value\n    this.types = types.value\n    this.args = args\n\n    return this.offset\n  }\n}\n","import { isInt, isDate } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/** 70 years in seconds */\nexport const SECONDS_70_YEARS = 2208988800\n/** 2^32 */\nexport const TWO_POWER_32 = 4294967296\n\n/**\n * Timetag helper class for representing NTP timestamps and conversion between\n * them and javascript representation.\n */\nexport class Timetag {\n  /**\n   * Create a Timetag instance.\n   * @param {number} seconds Initial NTP seconds value\n   * @param {number} fractions Initial NTP fractions value\n   */\n  constructor(seconds = 0, fractions = 0) {\n    if (!(isInt(seconds) && isInt(fractions))) {\n      throw new Error('OSC Timetag constructor expects values of type integer number.')\n    }\n\n    /** @type {number} seconds */\n    this.seconds = seconds\n    /** @type {number} fractions */\n    this.fractions = fractions\n  }\n\n  /**\n   * Converts from NTP to JS representation and back\n   * @param {number} milliseconds Converts from JS milliseconds to NTP and write seconds\n   * and fractions. Leave empty for returning the converted javascript timestamp from the\n   * NTP representation\n   * @return {number} Javascript timestamp\n   */\n  timestamp(milliseconds) {\n    let seconds\n\n    if (typeof milliseconds === 'number') {\n      seconds = milliseconds / 1000\n      const rounded = Math.floor(seconds)\n\n      this.seconds = rounded + SECONDS_70_YEARS\n      this.fractions = Math.round(TWO_POWER_32 * (seconds - rounded))\n\n      return milliseconds\n    }\n\n    seconds = this.seconds - SECONDS_70_YEARS\n    return (seconds + (this.fractions / TWO_POWER_32)) * 1000\n  }\n}\n\n/**\n * 64-bit big-endian fixed-point time tag, semantics defined below OSC Atomic Data Type.\n */\nexport default class AtomicTimetag extends Atomic {\n  /**\n   * Create a AtomicTimetag instance\n   * @param {number|Timetag|Date} value Initial date, leave empty if\n   * you want it to be the current date\n   */\n  constructor(value) {\n    let timetag = new Timetag()\n\n    if (value instanceof Timetag) {\n      timetag = value\n    } else if (isInt(value)) {\n      timetag.timestamp(value)\n    } else if (isDate(value)) {\n      timetag.timestamp(value.getTime())\n    } else {\n      // set to current date when nothing was given\n      timetag.timestamp(Date.now())\n    }\n\n    super(timetag)\n  }\n\n  /**\n   * Interpret the given timetag as packed binary data.\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC AtomicTimetag can not be encoded with empty value.')\n    }\n\n    const { seconds, fractions } = this.value\n    const data = new Uint8Array(8)\n    const dataView = new DataView(data.buffer)\n\n    dataView.setInt32(0, seconds, false)\n    dataView.setInt32(4, fractions, false)\n\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView and read a timetag.\n   * @param {DataView} dataView The DataView holding the binary representation of the timetag\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicTimetag expects an instance of type DataView.')\n    }\n\n    const seconds = dataView.getUint32(initialOffset, false)\n    const fractions = dataView.getUint32(initialOffset + 4, false)\n\n    /** @type {Timetag} value */\n    this.value = new Timetag(seconds, fractions)\n    /** @type {number} offset */\n    this.offset = initialOffset + 8\n\n    return this.offset\n  }\n}\n","import { isArray, isInt } from './common/utils'\nimport EncodeHelper from './common/helpers'\n\nimport Packet from './packet'\nimport Message from './message'\nimport AtomicString from './atomic/string'\nimport AtomicInt32 from './atomic/int32'\nimport AtomicTimetag from './atomic/timetag'\n\n/** OSC Bundle string */\nexport const BUNDLE_TAG = '#bundle'\n\n/**\n * An OSC Bundle consist of an Timetag and Bundle Elements.\n * The contents are either OSC Messages or more OSC Bundles.\n */\nexport default class Bundle {\n  /**\n   * Create a Bundle instance\n   * @param {...*} args Timetag and elements\n   *\n   * @example\n   * const timetag = new AtomicTimetag()\n   * const bundle = new Bundle(timetag)\n   *\n   * @example\n   * const timetag = new AtomicTimetag()\n   * const message = new Message('/test/path', 51.2)\n   * const anotherBundle = new Bundle([message], timetag)\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   * const anotherMessage = new Message('/test/message', 'test', 12)\n   * const anotherBundle = new Bundle(message, anotherMessage)\n   */\n  constructor(...args) {\n    /** @type {number} offset */\n    this.offset = 0\n    /** @type {AtomicTimetag} timetag */\n    this.timetag = new AtomicTimetag()\n    /** @type {array} bundleElements */\n    this.bundleElements = []\n\n    if (args.length > 0) {\n      // first argument is an AtomicTimetag\n      if (args[0] instanceof AtomicTimetag) {\n        this.timetag = args.shift()\n      } else if (isArray(args[0])) {\n        // first argument is an Array of Bundle elements\n        args[0].forEach((item) => {\n          this.add(item)\n        })\n\n        // second argument is an AtomicTimetag\n        if (args.length > 1 && args[1] instanceof AtomicTimetag) {\n          this.timetag = new AtomicTimetag(args[1])\n        }\n      } else {\n        // take all arguments as Bundle elements\n        args.forEach((item) => {\n          this.add(item)\n        })\n      }\n    }\n  }\n\n  /**\n   * Take a JavaScript timestamp to set the Bundle's timetag\n   * @param {number} ms JS timestamp in milliseconds\n   *\n   * @example\n   * const bundle = new Bundle()\n   * bundle.timestamp(Date.now() + 5000) // in 5 seconds\n   */\n  timestamp(ms) {\n    if (!isInt(ms)) {\n      throw new Error('OSC Bundle needs an Integer for setting its timestamp.')\n    }\n\n    this.timetag = new AtomicTimetag(ms)\n  }\n\n  /**\n   * Add a Message or Bundle to the list of elements\n   * @param {Bundle|Message} item\n   */\n  add(item) {\n    if (!(item instanceof Message || item instanceof Bundle)) {\n      throw new Error('OSC Bundle contains only Messages and Bundles.')\n    }\n\n    this.bundleElements.push(item)\n  }\n\n  /**\n   * Interpret the Bundle as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    const encoder = new EncodeHelper()\n\n    // an OSC Bundle consists of the OSC-string \"#bundle\"\n    encoder.add(new AtomicString(BUNDLE_TAG))\n\n    // followed by an OSC Time Tag\n    if (!this.timetag) {\n      this.timetag = new AtomicTimetag()\n    }\n\n    encoder.add(this.timetag)\n\n    // followed by zero or more OSC Bundle Elements\n    this.bundleElements.forEach((item) => {\n      encoder.add(new AtomicInt32(item.pack().byteLength))\n      encoder.add(item)\n    })\n\n    return encoder.merge()\n  }\n\n  /**\n   * Unpack binary data to read a Bundle\n   * @param {DataView} dataView The DataView holding the binary representation of a Bundle\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Bundle expects an instance of type DataView.')\n    }\n\n    // read the beginning bundle string\n    const head = new AtomicString()\n    head.unpack(dataView, initialOffset)\n\n    if (head.value !== BUNDLE_TAG) {\n      throw new Error('OSC Bundle does not contain a valid #bundle head.')\n    }\n\n    // read the timetag\n    const timetag = new AtomicTimetag()\n    let offset = timetag.unpack(dataView, head.offset)\n\n    // read the bundle elements\n    this.bundleElements = []\n\n    while (offset < dataView.byteLength) {\n      const packet = new Packet()\n      const size = new AtomicInt32()\n\n      offset = size.unpack(dataView, offset)\n      offset = packet.unpack(dataView, offset)\n\n      this.bundleElements.push(packet.value)\n    }\n\n    this.offset = offset\n    this.timetag = timetag\n\n    return this.offset\n  }\n}\n","import Bundle, { BUNDLE_TAG } from './bundle'\nimport Message from './message'\nimport AtomicString from './atomic/string'\n\n/**\n * The unit of transmission of OSC is an OSC Packet. The contents\n * of an OSC packet must be either an OSC Message or an OSC Bundle.\n */\nexport default class Packet {\n  /**\n   * Create a Packet instance holding a Message or Bundle\n   * @param {Message|Bundle} value Initial Packet value\n   */\n  constructor(value) {\n    if (value && !(value instanceof Message || value instanceof Bundle)) {\n      throw new Error('OSC Packet can only consist of Message or Bundle.')\n    }\n\n    /** @type {Message|Bundle} value */\n    this.value = value\n    /** @type {number} offset */\n    this.offset = 0\n  }\n\n  /**\n   * Packs the Packet value, this is more like a wrapper, you could also skip\n   * the Packet and directly pack the Message or Bundle.\n   * @return {Uint8Array} Packed binary data\n   *\n   * @example\n   * const message = new Message('/test/path', 21.5, 'test')\n   * const packet = new Packet(message)\n   * const packetBinary = packet.pack() // then send it via udp etc.\n   *\n   * // or skip the Packet for convenience\n   * const messageBinary = message.pack()\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC Packet can not be encoded with empty body.')\n    }\n\n    return this.value.pack()\n  }\n\n  /**\n   * Unpack binary data from DataView for Messages or Bundles\n   * @param {DataView} dataView The DataView holding the binary representation of a Packet\n   * @param {number} initialOffset Offset of DataView before unpacking\n   * @param {AtomicTimetag} timetag Pass over a AtomicTimetag, this is needed to inherit\n   * timetags from parent Bundles\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0, timetag) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Packet expects an instance of type DataView.')\n    }\n\n    if (dataView.byteLength % 4 !== 0) {\n      throw new Error('OSC Packet byteLength has to be a multiple of four.')\n    }\n\n    const head = new AtomicString()\n    head.unpack(dataView, initialOffset)\n\n    let item\n\n    // check if Packet is a Bundle or a Message\n    if (head.value === BUNDLE_TAG) {\n      item = new Bundle()\n    } else {\n      item = new Message()\n\n      // inherit the AtomicTimetag from the parent bundle when passed over\n      if (timetag) {\n        item.timetag = timetag\n      }\n    }\n\n    item.unpack(dataView, initialOffset)\n\n    this.offset = item.offset\n    this.value = item\n\n    return this.offset\n  }\n}\n"],"names":["isInt","n","Number","isFloat","isString","isArray","Object","prototype","toString","call","isBlob","Uint8Array","isDate","Date","pad","typeTag","item","Error","prepareAddress","obj","address","join","length","slice","EncodeHelper","data","byteLength","buffer","pack","push","result","offset","forEach","set","Atomic","value","method","dataView","DataView","initialOffset","AtomicInt32","AtomicFloat32","AtomicString","terminated","i","charCodeAt","charcode","getUint8","String","fromCharCode","apply","AtomicBlob","setInt32","getInt32","Message","types","args","timetag","shift","map","encoder","Helper","add","argument","merge","unpack","next","type","SECONDS_70_YEARS","TWO_POWER_32","Timetag","seconds","fractions","milliseconds","rounded","Math","floor","round","AtomicTimetag","timestamp","getTime","now","getUint32","BUNDLE_TAG","Bundle","bundleElements","ms","head","packet","Packet","size"],"mappings":"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"}